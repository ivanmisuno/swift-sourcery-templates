<%#
  A type erasure is a Swift-language pattern to combine both generic type parameters and associatedtypes, e.g.:
  ```swift
  protocol PresenterType {
    associatedtype Model
    func present(_ model: Model)
  }
  class TablePresenter<Model>: PresenterType {
    // ...
  }
  class CollectionPresenter<Model>: PresenterType {
    // ...
  }
  struct CarModel {}
  struct ShipModel {}
  let carPresenters = [AnyPresenter<CarModel>(TablePresenter()), AnyPresenter<CarModel>(CollectionPresenter())]
  let shipPresenters = [AnyPresenter<ShipModel>(TablePresenter()), AnyPresenter<ShipModel>(CollectionPresenter())]
  ```
  The pattern implemented here follows this article: https://www.bignerdranch.com/blog/breaking-down-type-erasures-in-swift/
-%>
<%- include("_header") -%>
<%- includeFile("Utility/Utility") -%>
<%- includeFile("Utility/StringsLettercase") -%>
<%_
  let typesToProcess = types.protocols.filter { $0.annotations["TypeErase"] != nil }
  generateAdditionalImports(typesToProcess)

  for type in typesToProcess {
    let associatedTypes: [(associatedType: String, constraints: [String])] = extractAssociatedTypes(type)
    let genericTypesModifier = !associatedTypes.isEmpty ? "<\(associatedTypes.map { $0.associatedType }.joined(separator: ", "))>" : ""
    let genericTypesConstraints: String = {
        let constraints = associatedTypes
          .flatMap { associatedType in
            return associatedType.constraints.map { "\(associatedType.associatedType): \($0)" }
           }
        return !constraints.isEmpty ? " where \(constraints.joined(separator: ", "))" : ""
    }()

    let allVariables = type.allVariables.filter { !$0.isStatic }
    let allMethods = type.allMethods.filter { !$0.isStatic }
-%>

// MARK: - Type erasure for `<%=type.name%>`

private class _Any<%=type.name%>Base<%=genericTypesModifier%>: <%=type.name%><%=genericTypesConstraints%> {
    init() {
        guard type(of: self) != _Any<%=type.name%>Base.self else {
            fatalError("_Any<%=type.name%>Base<%=genericTypesModifier%> instances can not be created; create a subclass instance instead")
        }
    }
    <%_ if !allVariables.isEmpty { -%>

    <%_ for p in allVariables { -%>
    var <%=p.name%>: <%=p.typeName%> {
        get { fatalError("Must override") }
        <% if p.isMutable { %>set { fatalError("Must override") }<% } %>
    }
    <%_ } -%>
    <%_ } -%>
    <%_ if !allMethods.isEmpty { -%>

    <%_ for m in allMethods { -%>
    func <%=m.name%> -> <%=m.returnTypeName%> {
        fatalError("Must override")
    }
    <%_ } -%>
    <%_ } -%>
}

private final class _Any<%=type.name%>Box<Concrete: <%=type.name%>>: _Any<%=type.name%>Base<%=!associatedTypes.isEmpty ? "<\(associatedTypes.map{"Concrete.\($0.associatedType)"}.joined(separator: ", "))>" : ""%> {
    private let concrete: Concrete
    <%_ for a in associatedTypes { -%>
    typealias <%=a.associatedType%> = Concrete.<%=a.associatedType%>
    <%_ } -%>

    init(_ concrete: Concrete) {
        self.concrete = concrete
    }
    <%_ if !allVariables.isEmpty { -%>

    <%_ for p in allVariables { -%>
    override var <%=p.name%>: <%=p.typeName%> {
        get { return concrete.<%=p.name%> }
        <% if p.isMutable { %>set { concrete.<%=p.name%> = newValue }<% } %>
    }
    <%_ } -%>
    <%_ } -%>
    <%_ if !allMethods.isEmpty { -%>

    <%_ for m in allMethods { -%>
    override func <%=m.name%> -> <%=m.returnTypeName%> {
        return concrete.<%=m.callName%>(<%= m.parameters.map { "\($0.argumentLabel != nil ? "\($0.argumentLabel!): " : "")\($0.`inout` ? "inout ": "")\($0.name)" }.joined(separator: ", ") %>)
    }
    <%_ } -%>
    <%_ } -%>
}

final class Any<%=type.name%><%=genericTypesModifier%>: <%=type.name%><%=genericTypesConstraints%> {
    private let box: _Any<%=type.name%>Base<%=genericTypesModifier%>

    init<Concrete: <%=type.name%>>(_ concrete: Concrete)<%=!associatedTypes.isEmpty ? " where \(associatedTypes.map {"Concrete.\($0.associatedType) == \($0.associatedType)"}.joined(separator: ", "))" : ""%> {
        self.box = _Any<%=type.name%>Box(concrete)
    }
    <%_ if !allVariables.isEmpty { -%>

    <%_ for p in allVariables { -%>
    var <%=p.name%>: <%=p.typeName%> {
        get { return box.<%=p.name%> }
        <% if p.isMutable { %>set { box.<%=p.name%> = newValue }<% } %>
    }
    <%_ } -%>
    <%_ } -%>
    <%_ if !allMethods.isEmpty { -%>

    <%_ for m in allMethods { -%>
    func <%=m.name%> -> <%=m.returnTypeName%> {
        return box.<%=m.callName%>(<%= m.parameters.map { "\($0.argumentLabel != nil ? "\($0.argumentLabel!): " : "")\($0.`inout` ? "inout ": "")\($0.name)" }.joined(separator: ", ") %>)
    }
    <%_ } -%>
    <%_ } -%>
}
<%_ -%>
<% } -%>
